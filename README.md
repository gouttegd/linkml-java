LinkML-Java – LinkML runtime library for Java
=============================================

LinkML-Java is an implementation of [LinkML](https://linkml.io/), the
Linked Data Modeling Language, for the Java language.

Project aims
------------
The project’s primary aim is to provide a runtime library to facilitate
working with LinkML-defined instance data – that is conformant to a
LinkML schema known at compile-time – from within a Java program, by
offering classes and methods to load/write the data from/to various
formats, and validate and manipulate said data.

Secondary aims will include:

* Dynamic use of schemas: Supporting manipulation of data that is
  conformant to a schema that is only discovered at runtime.

* Built-in Java code generation: Allowing the generation of the Java
  code representing a LinkML schema directly from the runtime library
  (instead of having to rely on LinkML-Py’s code generator), so that
  the code generation step can be easily integrated within the build
  process of a Java project (this will most likely take the form of a
  Maven plugin).

Implementation status
---------------------
For now, the runtime supports loading and writing data from and to the
YAML and JSON formats. Support for other formats, especially RDF, will
be added later.

Notable limitations include:

* Incomplete support for type designators: the use of URIs to identify
  the runtime type of an object is not supported yet.

* No support for dynamic enums: only “static” enums, whose permissible
  values are fully known at compile-time, are supported.

Usage
-----
Currently, using the runtime supposes that the Java code representing
the LinkML-defined model is already available. Typically, it would have
been generated by LinkML-Py’s tool (`linkml generate java`).

Importantly, for the runtime to work properly the code must satisfy the
following constraints:

* All classes must have predictable read/write accessors (`getX`/`setX`
  methods) for every single LinkML slot.

* The name of the field representing a slot may differ from the name of
  the original LinkML slot (this is typically done so that the code
  looks more “Java-ish”), but in that case the field must be annotated
  with a `@SlotName` annotation providing the original name.

* If a class has an identifier slot or a key slot, that slot must be
  annotated with a `@Identifier` or a `@Identifier(isGlobal=false)`
  annotation, respectively.

* If the value of a slot is expected to be inlined, that slot must be
  annotated with a `@Inlined` or `@Inlined(asList=true)` annotation.

LinkML-Py’s own code generator already meets the first requirement
(through the use of [Lombok](https://projectlombok.org) annotations);
hopefully it will soon provide an option to also automatically meet all
the other requirements.

Assuming you have a LinkML-defined model with a root class named `Foo`,
and that you have generated code meeting the above requirements, you can
read an instance of `Foo` from a YAML file as follows:

```java
// Parse the YAML file into a generic Map -- nothing LinkML specific
// here, we just rely on the Jackson library (though any other library
// that can parse YAML into a Map would do).
ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
FileInputStream stream = new FileInputStream(new File("foo.yaml"));
Object raw = mapper.readValue(stream, Map.class);

// LinkML magic starts here.
// ConverterContext is the main interface to the LinkML runtime. We use
// it here to convert the raw map into an actual Foo object, and to
// ensure that forward references to global objects are resolved.
ConverterContext ctx = new ConverterContext();
Foo foo = (Foo) ctx.getConverter(Foo.class).convert(raw, ctx);
ctx.finalizeAssignments();

// Now do whatever you need with the foo object
```

To read a _list_ of objects instead (if your LinkML schema does not
define a top-level object, as for example with the
[KGCL schema](https://w3id.org/kgcl/)):

```java
List<Object> rawList = mapper.readValue(stream, List.class);
List<Change> kgclChangeset = new ArrayList<>();
for ( Object rawItem : rawList ) {
    kgclChangeset.add((Change) ctx.getConverter(Change.class).convert(rawItem, ctx);
}
ctx.finalizeAssignments();

// Now do whatever you need with the list of Change objects
```

To serialise an object back to YAML, we do the opposite – use the
`ConverterContext` to convert the object into a raw map, that we can
then give to the Jackson mapper:

```java
raw = ctx.getConverter(Foo.class).serialise(foo, ctx);
mapper.writeValue(System.out, raw);
```

(More documentation will come soon.)

Homepage and repository
-----------------------
The project is currently located at
<https://github.com/gouttegd/linkml-java>, which both hosts the
repository and acts as a temporary home page.

Copying
-------
LinkML-Java is distributed under the terms of the 3-clause BSD license.
The full license is included in the [COPYING file](COPYING) of the
source distribution.
