LinkML-Java – LinkML runtime library for Java
=============================================

LinkML-Java is an implementation of [LinkML](https://linkml.io/), the
Linked Data Modeling Language, for the Java language.

Project aims
------------
The project’s primary aim is to provide a runtime library to facilitate
working with LinkML-defined instance data – that is conformant to a
LinkML schema known at compile-time – from within a Java program, by
offering classes and methods to load/write the data from/to various
formats, and validate and manipulate said data.

Secondary aims will include:

* Dynamic use of schemas: Supporting manipulation of data that is
  conformant to a schema that is only discovered at runtime.

* Built-in Java code generation: Allowing the generation of the Java
  code representing a LinkML schema directly from the runtime library
  (instead of having to rely on LinkML-Py’s code generator), so that
  the code generation step can be easily integrated within the build
  process of a Java project (this will most likely take the form of a
  Maven plugin).

Implementation status
---------------------
For now, the runtime supports loading and writing data from and to the
YAML and JSON formats. Support for other formats, especially RDF, will
be added later.

Notable limitations include:

* Incomplete support for type designators: the use of URIs to identify
  the runtime type of an object is not supported yet.

* No support for dynamic enums: only “static” enums, whose permissible
  values are fully known at compile-time, are supported.

Usage
-----
Currently, using the runtime supposes that the Java code representing
the LinkML-defined model is already available. Typically, it would have
been generated by LinkML-Py’s tool (`linkml generate java`).

Importantly, for the runtime to work properly the code must satisfy the
following constraints:

* All classes must have predictable read/write accessors (`getX`/`setX`
  methods) for every single LinkML slot.

* The name of the field representing a slot may differ from the name of
  the original LinkML slot (this is typically done so that the code
  looks more “Java-ish”), but in that case the field must be annotated
  with a `@SlotName` annotation providing the original name.

* If a class has an identifier slot or a key slot, that slot must be
  annotated with a `@Identifier` or a `@Identifier(isGlobal=false)`
  annotation, respectively.

* If the value of a slot is expected to be inlined, that slot must be
  annotated with a `@Inlined` or `@Inlined(asList=true)` annotation.

LinkML-Py’s own code generator already meets the first requirement
(through the use of [Lombok](https://projectlombok.org) annotations);
hopefully it will soon provide an option to also automatically meet all
the other requirements.

Assuming you have a LinkML-defined model with a root class named `Foo`,
and that you have generated code meeting the above requirements, you can
read an instance of `Foo` from a YAML file as follows:

```java
YAMLLoader loader = new YAMLLoader();
Foo foo = loader.loadObject(new File("foo.yaml"), Foo.class);
```

To read a _list_ of objects instead (if your LinkML schema does not
define a top-level object, as for example with the
[KGCL schema](https://w3id.org/kgcl/)):

```java
List<Change> kgclChangeset = loader.loadObjects(new File("changes.kgcl"), Change.class);
```

(More documentation will come soon. Also please note that the interface
of `YAMLLoader` is not definitive yet.)

Homepage and repository
-----------------------
The project is currently located at
<https://github.com/gouttegd/linkml-java>, which both hosts the
repository and acts as a temporary home page.

Copying
-------
LinkML-Java is distributed under the terms of the 3-clause BSD license.
The full license is included in the [COPYING file](COPYING) of the
source distribution.
